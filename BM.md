##BM算法

本来想着直接写BM算法,但是发现思路还是有一些混乱,那就再仔细的分析一遍其中的逻辑.

首先还是两个规则:坏字符和好后缀

- 

如果说,模式串和文本串相匹配,则i--;j--;
如果碰到了不匹配:这个时候模式串要进行右移,好在无论右移多少,因为和模式串最右边字符匹配的字符变化了,并且未知,所以我们总要将j重置.那么现在的问题就是i变成了多少.

如果,j==pLen-1,也就是说在移动后首次匹配或者第一次匹配就失败了,这种情况就没有好后缀,直接右移pLen-(-1);

如果,j!=pLen-1,也就是说已经产生好后缀了.那我们就要检查好后缀在模式串中再次出现的位置.

这里产生了一个问题就是,是否在产生好后缀之后,利用好后缀原则右移的数量一定比坏字符多.

还是举例说明

		ABBCDABDDE
		ABDD

因为很多东西现在不解决,以后还是会解决,所以就在这里一并解决了.

我们开始进行第一次的比较,D!=C且j==pLen-1,所以,我们可以直接使用坏字符规则,将模式串右移4-3位得到:

		ABBCDABDDE
		 ABDD

这时我们看到,模式串的后三个都是匹配的,既然匹配就有了好后缀D,好后缀再次出现的位置是2,这是右移3-2=1.而根据坏字符则右移3-(-1)=4.所以好后缀小于坏字符,所以还是要进行比较的.

后移四位后:

		ABBCDABDDE
		     ABDD

开始匹配,成功.返回i值.

